## Resenha dos Capítulos 6 e 7 do livro Engenharia de Software Moderna 

## 6 Padrões de Projeto: 

Começando o capítulo podemos ver a abordagem da origem dos padrões de projeto no desenvolvimento de software, inspirados nas ideias do arquiteto Cristopher Alexander. Adaptados pela Gang of Four em 1995, esses padrões oferecem soluções reutilizáveis para problemas recorrentes em design de software, promovendo flexibilidade e extensibilidade. Além de facilitar a implementação de sistemas próprios e a compreensão de sistemas de terceiros, os padrões de projeto criaram um vocabulário comum entre desenvolvedores. O texto explora três categorias principais de padrões – criacionais, estruturais e comportamentais – e destaca a importância de projetar sistemas com foco em futuras mudanças, evitando a necessidade de grandes reprojetos. 

O capítulo sobre o padrão Fábrica começa abordando um problema comum em sistemas que precisam criar objetos de diferentes tipos, dependendo de certas condições. No exemplo, as funções estão criando diretamente objetos TCPChannel, o que se torna um problema quando há a necessidade de usar outro protocolo, como UDP, pois o código não está preparado para essa flexibilidade. Aqui, o autor destaca o princípio Aberto/Fechado, e como o código, do jeito que está, violaria essa regra.  

Achei interessante a forma como o padrão Fábrica resolve isso, encapsulando a criação dos objetos dentro de um método estático que faz essa "mágica" de criar os canais de comunicação sem que as funções saibam o que está sendo criado exatamente. Assim, é possível mudar de TCP para UDP de forma simples, alterando apenas o método fábrica. Essa solução é simples e eficiente, além de aplicar o princípio de preferir interfaces a classes concretas, o que eu vejo como uma boa prática para manter o código flexível. 

O padrão Singleton, por outro lado, sempre me pareceu um pouco mais polêmico, e o capítulo deixa isso claro. Ele resolve o problema de ter várias instâncias de uma classe Logger espalhadas pelo código, garantindo que apenas uma única instância exista e seja reutilizada. A ideia faz sentido quando pensamos em um recurso que deve ser único, como o próprio arquivo de log mencionado. Porém, entendo a crítica ao Singleton, principalmente porque ele se assemelha a uma variável global disfarçada, o que pode levar a um acoplamento forte entre as classes. Isso pode complicar bastante os testes automáticos, já que o estado da aplicação pode depender de um Singleton em qualquer parte do código. É um padrão útil, mas acho que deve ser usado com cuidado. 

No capítulo sobre o padrão Proxy, a discussão aborda a introdução de um intermediário entre o cliente e o objeto base, usando a classe BookSearch como exemplo. O conceito é fascinante porque, à medida que a popularidade do serviço de pesquisa de livros cresce, a necessidade de otimizar o desempenho por meio de um sistema de cache se torna evidente. O autor destaca a importância de manter a classe BookSearch coesa e aderente ao Princípio da Responsabilidade Única, evitando misturar a lógica de pesquisa com a implementação do cache. Isso é algo que eu valorizo muito no desenvolvimento, pois a clareza e a separação de responsabilidades em um sistema são fundamentais para a manutenção e escalabilidade. 

A solução proposta, que envolve a utilização de um proxy, é uma maneira inteligente de agregar funcionalidades não-funcionais, como o cache, sem comprometer a integridade da classe original. O proxy serve como um guardião, verificando se o livro já está em cache antes de realizar uma pesquisa mais demorada. Esse modelo não só melhora a performance, mas também permite que a classe BookSearch permaneça focada em suas responsabilidades principais. A ideia de usar interfaces para ocultar a complexidade da implementação é algo que realmente ressoa comigo. Isso promove um desacoplamento que facilita a troca de implementações e a adição de novas funcionalidades sem perturbar o funcionamento do sistema. No geral, o capítulo reforça a importância de padrões de projeto na construção de software robusto e bem estruturado, e essa abordagem me inspira a aplicar essas ideias em meus próprios projetos. 

No capítulo sobre o padrão Adaptador, a análise da situação em que um sistema precisa controlar diferentes projetores multimídia é muito pertinente. O autor utiliza exemplos de projetores de marcas distintas, como Samsung e LG, para ilustrar como as interfaces de controle podem ser incompatíveis devido a métodos e parâmetros diferentes. Essa situação reflete um desafio comum no desenvolvimento de software, onde integramos sistemas de diferentes fornecedores. A proposta de utilizar um adaptador para unificar a interface de controle é uma solução elegante que demonstra como é possível conectar componentes que, à primeira vista, parecem não compatíveis. A implementação da classe AdaptadorProjetorSamsung, que traduz o método turnOn da classe ProjetorSamsung para a interface Projetor, exemplifica como os padrões de design podem facilitar a integração de sistemas existentes sem necessidade de modificar seu código. 

A utilização do padrão Adaptador não apenas simplifica o uso dos projetores, mas também mantém a flexibilidade do sistema, permitindo que novos projetores sejam facilmente integrados por meio de suas próprias classes adaptadoras. Essa abordagem reforça a importância da reutilização de código e a adaptação às mudanças, algo que considero essencial em projetos de software modernos. A forma como o autor apresenta o problema e a solução me fez refletir sobre a aplicação prática desse padrão em projetos que já presenciei. 

Na sequência, a introdução do padrão Fachada fornece uma visão sobre como simplificar a interface de um sistema complexo. O exemplo do interpretador de uma linguagem mostra claramente como a criação de uma classe Fachada pode ocultar a complexidade de interações internas, permitindo que os desenvolvedores utilizem uma interface mais intuitiva e direta. A transformação de várias chamadas de métodos em uma única linha de código ilustra como a Fachada pode não apenas reduzir o esforço de programação, mas também melhorar a legibilidade e a manutenção do código. Essa abordagem ressoa comigo, pois valorizo soluções que reduzem a curva de aprendizado para novos desenvolvedores e promovem uma experiência mais fluida ao interagir com sistemas complexos. Em suma, tanto o padrão Adaptador quanto o Fachada são ferramentas valiosas que facilitam a integração e a interação com sistemas variados, promovendo um design mais limpo e eficiente. 

Avançando um pouco para o próximo capítulo, o autor aborda dois padrões importantes: o Padrão Decorador e o Padrão Strategy, ambos oferecendo soluções para problemas comuns no desenvolvimento de software. 

O Padrão Decorador é uma abordagem muito eficiente para a adição de funcionalidades a classes existentes, evitando a complexidade que vem com o uso excessivo da herança. O exemplo do sistema de comunicação remota ilustra bem esse ponto. Em vez de criar um número insustentável de subclasses para cada combinação de funcionalidades opcionais — como buffers, compactação e logging — o Decorador permite que o cliente adicione essas funcionalidades dinamicamente, por meio de composição. Isso não só simplifica o design, mas também melhora a manutenção do código. A ideia de encapsular as funcionalidades em decoradores e delegar chamadas para os canais subjacentes promove um código mais limpo e modular.  

Por outro lado, o Padrão Strategy é essencial para garantir que classes possam ser estendidas sem a necessidade de modificar seu código fonte. O exemplo da classe MyList, que inicialmente utilizava apenas o algoritmo de ordenação Quicksort, destaca a importância da flexibilidade na escolha dos algoritmos. Com o Strategy, o cliente pode definir e alterar a estratégia de ordenação conforme suas necessidades, respeitando o princípio Aberto/Fechado. Isso é um exemplo claro de como encapsular algoritmos em suas próprias classes e torná-los intercambiáveis pode levar a um design de software mais robusto e adaptável. 

Ambos os padrões promovem uma melhor organização do código e facilitam a manutenção e a extensão de funcionalidades, o que é fundamental em projetos que precisam se adaptar rapidamente às mudanças. A ênfase no uso de composição em vez de herança no Decorador, assim como a capacidade de alternar algoritmos de forma flexível no Strategy, são lições valiosas para qualquer desenvolvedor que deseja criar sistemas escaláveis e de fácil manutenção. Esse capítulo realmente destaca a importância de entender e aplicar esses padrões para melhorar a qualidade do software e a eficiência no desenvolvimento. 

O padrão Observador se destaca como uma solução elegante para a implementação de sistemas que requerem a comunicação entre um sujeito e vários observadores. Um exemplo prático apresentado é o de um sistema de monitoramento de uma estação meteorológica, onde temos a classe Temperatura representando os dados que mudam e as classes TermometroCelsius e TermometroFahrenheit, que servem como visualizadores desses dados. A necessidade de manter a separação entre a lógica do modelo (Temperatura) e a interface de visualização (Termometro) é um ponto crucial, pois essa separação permite uma maior flexibilidade. A frequência com que as interfaces podem mudar — desde a atual interface textual até futuras interfaces web ou mobile — reforça a importância dessa abordagem. 

Ao implementar o padrão Observador, conseguimos evitar o acoplamento excessivo entre os sujeitos e os observadores. Isso é feito através da utilização de uma classe base Subject, que gerencia a lista de observadores e os notifica sempre que ocorre uma mudança de estado. Assim, quando a temperatura é alterada, todos os termômetros associados são automaticamente atualizados. Este mecanismo de notificação não só permite reuso em outras classes como PressaoAtmosferica e Barometro, mas também assegura que o sistema permaneça escalável e fácil de manter. 

A simplicidade e eficácia do padrão Observador estão em sua capacidade de permitir que um sujeito não conheça diretamente seus observadores. Isso promove um design mais limpo e um código que pode ser facilmente expandido com novos tipos de observadores, sem a necessidade de alterações significativas na classe do sujeito. Como tal, o padrão se mostra altamente eficaz para sistemas dinâmicos que requerem notificação em tempo real e interações entre múltiplos componentes. 

Outro padrão relevante discutido é o Template Method, que fornece uma estrutura clara para a implementação de algoritmos com etapas que podem variar. O exemplo utilizado envolve a classe Funcionario, que define um método template para calcular o salário líquido de um funcionário, enquanto permite que subclasses como FuncionarioPublico e FuncionarioCLT implementem os cálculos específicos de descontos. Isso garante que o algoritmo geral permaneça intacto, enquanto as particularidades de cada tipo de funcionário são tratadas nas subclasses. 

Esse padrão é particularmente útil para garantir a consistência em processos comuns, permitindo que partes do código permaneçam estáveis e reutilizáveis, mesmo quando novas subclasses são introduzidas. A implementação de métodos abstratos dentro da classe base, que devem ser definidos pelas subclasses, é uma característica que reforça a ideia de que a lógica básica do algoritmo deve ser compartilhada, enquanto os detalhes são deixados para serem definidos conforme necessário. 

O conceito de inversão de controle mencionado no contexto do Template Method também é importante, pois permite que uma estrutura mais antiga chame métodos de subclasses mais novas. Essa flexibilidade é fundamental em frameworks e sistemas orientados a objetos, permitindo que desenvolvedores adicionem funcionalidades sem modificar o código existente. 

Por fim, o padrão Visitor é apresentado como uma solução para um problema comum em sistemas que operam sobre hierarquias de classes, como a do sistema de estacionamento discutido. Aqui, a classe base Veiculo e suas subclasses Carro, Onibus e Motocicleta são utilizadas para armazenar dados sobre veículos. O desafio surge quando é necessário realizar operações em todos os veículos, como imprimir informações ou persistir dados, sem modificar diretamente as classes das quais essas operações dependem. 

O padrão Visitor permite adicionar novas operações a classes existentes sem modificar suas implementações. Para isso, cada classe de veículo deve implementar um método accept, que aceita um objeto do tipo Visitor e chama o método apropriado. Essa abordagem permite que operações diferentes sejam realizadas sobre diferentes tipos de veículos sem a necessidade de conhecimento prévio do tipo específico, simulando o que se conhece como "double dispatch". 

Com a implementação do padrão Visitor, torna-se possível explorar a estrutura polimórfica do sistema de forma robusta e flexível, já que as operações podem ser adicionadas ou alteradas sem afetar a estrutura das classes de veículo. Assim, o padrão se torna uma ferramenta valiosa para manter o código limpo e adaptável, facilitando a introdução de novas funcionalidades no futuro. 

O capítulo 6 destaca a importância dos padrões de projeto na flexibilidade e adaptabilidade dos sistemas de software. Padrões como Fábrica, Decorador e Strategy permitem personalizar e parametrizar a funcionalidade das classes, facilitando a troca de objetos e a configuração de algoritmos. Contudo, a adoção desses padrões vem com um custo. É crucial analisar se a implementação de um padrão é realmente necessária; por exemplo, questionar se há a necessidade de criar objetos de tipos diferentes ou se algoritmos alternativos serão requeridos.  

Além disso, o uso excessivo de padrões pode levar à "paternite", onde a complexidade do sistema aumenta sem uma justificativa clara. John Ousterhout ressalta que a super-aplicação de padrões pode ser prejudicial, argumentando que nem todo problema precisa ser resolvido dessa maneira. O exemplo de decoradores na abertura de arquivos em Java ilustra bem essa questão, pois, em muitos casos, a implementação de funcionalidades adicionais pode complicar desnecessariamente a solução. Em suma, os padrões de projeto são valiosos, mas sua aplicação deve ser feita com cautela e reflexão sobre a necessidade real em cada situação. 
